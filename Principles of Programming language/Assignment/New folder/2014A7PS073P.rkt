#lang racket
(provide (all-defined-out))
(define inputFile (vector-ref (current-command-line-arguments) 0)) 
;(define inputFile "C:\\Users\\admin\\Documents\\test1.txt")
(define num 0)
(define unionlist '())
(define interlist '())
(define union 0)
(define intersec 0)
(define distlist '())
(define min 100)
(define id1 0)
(define id2 0)
(define triplet '())
(define step5 "\n")

(define (counter)
 (set! num (+ num 1)))

(define step1 (file->list inputFile))

(define (cluster list1)
  (map (lambda (i)
         (counter)
         (list num (list (symbol->string i)) '()))
         list1))

(define step2 (cluster step1))

(define (WtoWdistance aa bb)
  (set! unionlist '())
  (set! interlist '())
  (set! intersec 0)
  (map (lambda (i)
         (map (lambda (j)
                (if (eq? i j)(set! interlist (append interlist (list i)))
                               '()))
              (string->list bb)))
       (string->list aa))
  (set! interlist (remove-duplicates interlist))
  (set! unionlist (append (string->list aa) (string->list bb)))
  (set! unionlist (remove-duplicates unionlist))
  (set! union (length unionlist))
  (if (null? intersec) (set! intersec 0)
      (set! intersec (length interlist)))
      (set! distlist (append distlist (list (- 1 (/ intersec union))))))

(define (createlist lista listb)
       (if (null? listb)
                '();
                (begin
                  (cons (WtoWdistance (car lista) (car listb)) (createlist lista (cdr listb))))))

(define (createlist2 lista listb)
  (if (null? lista)
      '()
  (begin
    (append (createlist lista listb) (createlist2 (cdr lista) listb)))))

(define (CtoCdistance a b)
  (set! distlist '())
  (map (lambda(i)
         (map (lambda (j)
                (createlist2 (regexp-split #px" " i) (regexp-split #px" " j)))
              b))
         a)
  (if (and (eq? a b) (> (length a) 1))
      (append (list '100) distlist) 
      (sort distlist <)))

(define (newstep2 newlist secondlist)
  (if (null? secondlist)
      '()
     (if (= (car (car newlist)) (car (car secondlist))) (cons (list (car (car secondlist)) '100) (newstep2 newlist (cdr secondlist)))
         (cons (list (car (car secondlist)) (car (CtoCdistance (car (cdr (car newlist))) (car (cdr (car secondlist)))))) (newstep2 newlist (cdr secondlist)))
      )))

(define (newstep newlist secondlist)
  (if (null? newlist)
      '()
      (cons (list (car (car newlist)) (car (cdr (car newlist))) (newstep2 newlist secondlist)) (newstep (cdr newlist) secondlist))))

(define step3 (newstep step2 step2))

(define (findmin curlist)
  (map (lambda (i)
         (map (lambda (j)
               (if (> min (car (cdr j)))
                   (begin
                   (set! id1 (car i))
                   (set! id2 (car j))
                   (set! min (car (cdr j))))
                   '()))
        (car (reverse i))))
       curlist))

(define (remove mylist delid)
  (if (null? mylist)
      '()
      (if (= delid (car (car mylist)))
          (begin
            (set! triplet (append triplet (car (cdr (car mylist)))))
            (set! triplet (sort triplet string<?))
            (remove (cdr mylist) delid))
          (cons (car mylist) (remove (cdr mylist) delid)))))

(define (newcluster curlist)
  (set! min 100)
  (set! id1 0)
  (set! id2 0)
  (set! triplet '())
  (findmin curlist)
  (set! curlist (remove curlist id1))
  (set! curlist (remove curlist id2))
  (counter)
  (set! curlist (append curlist (list (list num triplet '()))))
  (newstep curlist curlist)
  )

(define ongoing step3)

(define (cont contlist)
  (set! ongoing (newcluster contlist))
  (set! contlist ongoing)
  (if (> (length ongoing) 8)
      (cont contlist)
      '()))

(define x (cont ongoing))
(define step4 ongoing)
(define list5 '())

(define (laststep lastlist)
  (map (lambda(i)
          (set! step5 (string-append step5 (string-join (car (cdr i))) "\n")))
       lastlist)
  )
(define y (laststep step4))